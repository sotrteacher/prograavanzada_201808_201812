#include "Polinomio.h"
/** Operador referencia a
 * Una referencia es un nombre alternativo (un sin\'onimo) para 
 * un objeto. Su utilizaci\'on la podemos observar en el dise\~no
 * de clases (por ejemplo, en el constructor de copia), en el valor 
 * retornado por una funci\'on para permitir que dicha funci\'on sea 
 * utilizada a ambos lados del operador de asignaci\'on (la funci\'on 
 * devuelve una referencia), o para permitir que los argumentosen la 
 * llamada puedan cambiar (paso de par\'ametros por referencia). La 
 * forma general de expresar una referencia es:
 * tipo& referencia=variable
 */



Polinomio& Polinomio::operator+(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B45 begin
{
	int grad=maximo(grado,PolObj.grado);
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;
	if(grado==grad){/*si el obj implicito es el de mayor grado*/
		for(int i=0;i<grado+1;i++){
			(ResPol.A+i)->n=(A+i)->n;
			(ResPol.A+i)->d=(A+i)->d;
		}
	}else{/*si el segundo operando es el de mayor grado*/
		for(int i=0;i<PolObj.grado+1;i++){
			(ResPol.A+i)->n=(PolObj.A+i)->n;
			(ResPol.A+i)->d=(PolObj.A+i)->d;
		}
	}
	if(grado<=grad){/*si el objeto implicito es el polinomio de menor grado*/
		//FIXMEEEEEEE!!!!!!        FIXED: 2018.03.13.15.21
		// i\in\{0,1,2,...,grado\} y queremos que los coeficientes del objeto 
		// impl\'icito se le sumen a los coeficientes del resultado correspondientes
		// a los \'indices \{grad - grado +0,grad - grado +1...,grad - 2,grad - 1,grad\} 
		for(int i=0;i<grado+1;i++){
//			*(ResPol.A+grad-grado+i)=*(ResPol.A+grad-grado+i)+*(PolObj.A+i);
			*(ResPol.A+grad-grado+i)=*(ResPol.A+grad-grado+i)+*(A+i);
		}
	}else{/*si el segundo operando es el de menor grado*/
		for(int i=0;i<ResPol.grado+1;i++){
//			*(ResPol.A+i)=*(ResPol.A+i)+*(A+i);
			*(ResPol.A+grad-PolObj.grado+i)=*(ResPol.A+grad-PolObj.grado+i)+*(PolObj.A+i);
		}
	}
	return ResPol;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B45 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Polinomio& Polinomio::operator-(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B48 begin
{
	int grad=maximo(grado,PolObj.grado);
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;
	if(grado==grad){/*si el obj implicito es el de mayor grado*/
		for(int i=0;i<grado+1;i++){
			(ResPol.A+i)->n=(A+i)->n;
			(ResPol.A+i)->d=(A+i)->d;
		}
	}else{/*si el segundo operando es el de mayor grado*/
		for(int i=0;i<PolObj.grado+1;i++){
			(ResPol.A+i)->n=(PolObj.A+i)->n;
			(ResPol.A+i)->d=(PolObj.A+i)->d;
		}
	}
	if(grado<=grad){/*si el objeto implicito es el polinomio de menor grado*/
		for(int i=0;i<grado+1;i++){
			*(ResPol.A+i)=*(ResPol.A+i)-*(PolObj.A+i);
		}
	}else{/*si el segundo operando es el de menor grado*/
		for(int i=0;i<ResPol.grado+1;i++){
			*(ResPol.A+i)=*(ResPol.A+i)-*(A+i);
		}
	}
	return ResPol;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B48 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Polinomio& Polinomio::operator*(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4B begin
{
	int grad=grado+PolObj.grado;
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;		/* ResultPolynomial */
	Rac factor1,factor2,factor1porfactor2,sumaparcial;
	for(int i=0;i<ResPol.grado+1;i++){
		*(ResPol.A+i)=Rac(0,1);	/* All coeffs of ResPol must be initialized  to \frac{0}{1} */
	}
	for(int k=0;k<grad+1;k++){
		for(int i=0;i<grado+1;i++){
			for(int j=0;j<PolObj.grado+1;j++){
				if((grado-i+PolObj.grado-j)==grad-k){
					factor1=*(A+i);
					factor2=*(new Rac((PolObj.A+j)->n,(PolObj.A+j)->d));
					factor1porfactor2=factor1*factor2;
					sumaparcial=*(ResPol.A+k)+factor1porfactor2;
					*(ResPol.A+k)=sumaparcial;
				}
			}
		}
	}
	return ResPol;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4B end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

//FcnDTrans& Polinomio::operator/(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4F begin
//{
//}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4F end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

ostream&  operator<<(ostream& ostreamOut, Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B52 begin
{ 
  Rac *rPt;
  int intV;
  ostreamOut<<"\\begin{array}{";
  for(int j=0;j<PolObj.grado+1;j++){
  	ostreamOut<<"c";
  }
  ostreamOut<<"}"<<endl;
 for(int i=0;i<PolObj.grado+1;i++){
 	rPt=(PolObj.A+i);
 	intV=rPt->n;
// 	cout<<"intV="<<intV<<endl;
	 if((PolObj.A+i)->d==1){
 		if(i){
 			ostreamOut<<"&"<<intV<<endl;
		 }else{
		 	ostreamOut<<intV<<endl;
		 }
	 }else{
		if(i){
	 		ostreamOut<<"&\\frac{"<<intV<<"}{"<<(PolObj.A+i)->d<<"}"<<endl;
		 }else{
	 		ostreamOut<<"\\frac{"<<intV<<"}{"<<(PolObj.A+i)->d<<"}"<<endl;
		 }
 	 }
  }
  ostreamOut<<"\\end{array}"<<endl;
  return ostreamOut;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B52 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Polinomio::Polinomio(int intGrado, Rac * RacPt):grado(intGrado),A(RacPt)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B56 begin
{ }
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B56 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

std::string Polinomio::string_show(){
	string Result="";
//	for(int i=0;i<grado+1;i++){
	for(int i=0;i<grado;i++){
		Result+=A[i].string_show()+":";
	}
	Result+=A[grado].string_show();
	return Result;
}
